"use strict";

function invariant(a, b, c) {
  if (!a) {
    throw a = b || "Minfied Error #" + c + "\n", "production" !== process.env.NODE_ENV && (a += getDebugOutput()), 
    (c = Error(a + helpUrl + c)).name = "Graphcache Error", c;
  }
}

function warn(a, b) {
  cache.has(a) || (console.warn(a + getDebugOutput() + helpUrl + b), cache.add(a));
}

function _ref(a) {
  for (var b = {}, c = 0; c < a.length; c++) {
    b[a[c].name] = a[c];
  }
  return b;
}

function expectObjectType(a, b) {
  invariant(a.types[b] && "OBJECT" === a.types[b].kind, "production" !== process.env.NODE_ENV ? "Invalid Object type: The type `" + b + "` is not an object in the defined schema, but the GraphQL document is traversing it." : "", 3);
}

function warnAboutResolver(a) {
  "production" !== process.env.NODE_ENV && warn("Invalid resolver: `" + a + "` is not in the defined schema, but the `resolvers` option is referencing it.", 23);
}

function warnAboutAbstractResolver(a, b) {
  "production" !== process.env.NODE_ENV && warn("Invalid resolver: `" + a + "` does not match to a concrete type in the schema, but the `resolvers` option is referencing it. Implement the resolver for the types that " + ("UNION" === b ? "make up the union" : "implement the interface") + " instead.", 26);
}

function _ref2(a, b, c) {
  var d, e;
  if (0 < (currentData.refCount[a] || 0)) {
    c.delete(a);
  } else {
    for (d in currentData.refLock) {
      if (0 < ((b = currentData.refLock[d])[a] || 0)) {
        return;
      }
      delete b[a];
    }
    delete currentData.refCount[a];
    c.delete(a);
    currentData.records.base.delete(a);
    if (d = currentData.links.base.get(a)) {
      currentData.links.base.delete(a);
      for (e in d) {
        updateRCForLink(c, currentData.refCount, d[e], -1);
      }
    }
  }
}

function _ref3(a, b) {
  for (var c in a) {
    writeLink(b, c, a[c]);
  }
}

function _ref4(a, b) {
  for (var c in a) {
    writeRecord(b, c, a[c]);
  }
}

function _ref2$1(a) {
  return wonka.fromArray(a[0]);
}

function _ref3$1(a, b) {
  return a.push(b), a;
}

function _ref4$1(a) {
  return "query" === a.kind && "network-only" !== a.context.requestPolicy;
}

function _ref5(a) {
  return "query" !== a.kind || "network-only" === a.context.requestPolicy;
}

function _ref9(a) {
  return "miss" !== a.outcome || "cache-only" === a.operation.context.requestPolicy;
}

var query, read, readRoot, readRootField, readFragment, readSelection, resolveResolverResult, resolveLink, isDataOrKey, addCacheOutcome, toRequestPolicy, cacheExchange, isOptimisticMutation, isOfflineError, offlineExchange, graphql = require("graphql"), core = require("@urql/core"), _rollupPluginBabelHelpers = require("./7832a774.js"), wonka = require("wonka"), getName = function(a) {
  return a.name.value;
}, getFragmentTypeName = function(a) {
  return a.typeCondition.name.value;
}, getFieldAlias = function(a) {
  return a.alias ? a.alias.value : getName(a);
}, getSelectionSet = function(a) {
  return a.selectionSet ? a.selectionSet.selections : [];
}, getTypeCondition = function(a) {
  return a.typeCondition ? getName(a.typeCondition) : null;
}, isFieldNode = function(a) {
  return a.kind === graphql.Kind.FIELD;
}, isInlineFragment = function(a) {
  return a.kind === graphql.Kind.INLINE_FRAGMENT;
}, getFieldArguments = function(a, b) {
  var e, f, g, h, c = {}, d = 0;
  if (a.arguments && a.arguments.length) {
    for (e = 0, f = a.arguments.length; e < f; e++) {
      null != (h = graphql.valueFromASTUntyped((g = a.arguments[e]).value, b)) && (c[getName(g)] = h, 
      d++);
    }
  }
  return 0 < d ? c : null;
}, filterVariables = function(a, b) {
  var c, d, e, f;
  if (b && a.variableDefinitions) {
    for (c = {}, d = 0, e = a.variableDefinitions.length; d < e; d++) {
      c[f = getName(a.variableDefinitions[d].variable)] = b[f];
    }
    return c;
  }
}, normalizeVariables = function(a, b) {
  var d, e, f, g, h, c = {};
  if (!b) {
    return c;
  }
  if (a.variableDefinitions) {
    for (d = 0, e = a.variableDefinitions.length; d < e; d++) {
      c[g = getName((f = a.variableDefinitions[d]).variable)] = void 0 === b[g] && f.defaultValue ? graphql.valueFromASTUntyped(f.defaultValue, b) : b[g];
    }
  }
  for (h in b) {
    h in c || (c[h] = b[h]);
  }
  return c;
}, helpUrl = "\nhttps://bit.ly/2XbVrpR#", cache = new Set, currentDebugStack = [], popDebugNode = function() {
  return currentDebugStack.pop();
}, pushDebugNode = function(a, b) {
  var c = "";
  b.kind === graphql.Kind.INLINE_FRAGMENT ? c = a ? 'Inline Fragment on "' + a + '"' : "Inline Fragment" : b.kind === graphql.Kind.OPERATION_DEFINITION ? c = (b.name ? '"' + b.name.value + '"' : "Unnamed") + " " + b.operation : b.kind === graphql.Kind.FRAGMENT_DEFINITION && (c = '"' + b.name.value + '" Fragment');
  c && currentDebugStack.push(c);
}, getDebugOutput = function() {
  return currentDebugStack.length ? "\n(Caused At: " + currentDebugStack.join(", ") + ")" : "";
}, getMainOperation = function(a) {
  for (var b = 0; b < a.definitions.length; b++) {
    if (a.definitions[b].kind === graphql.Kind.OPERATION_DEFINITION) {
      return a.definitions[b];
    }
  }
  invariant(!1, "production" !== process.env.NODE_ENV ? "Invalid GraphQL document: All GraphQL documents must contain an OperationDefinitionnode for a query, subscription, or mutation." : "", 1);
}, getFragments = function(a) {
  var b, c, d;
  for (b = {}, c = 0; c < a.definitions.length; c++) {
    (d = a.definitions[c]).kind === graphql.Kind.FRAGMENT_DEFINITION && (b[getName(d)] = d);
  }
  return b;
}, shouldInclude = function(a, b) {
  var d, e, f, c = a.directives;
  if (!c) {
    return !0;
  }
  for (d = 0, e = c.length; d < e; d++) {
    if (("include" === (a = getName(f = c[d])) || "skip" === a) && f.arguments && f.arguments[0] && "if" === getName(f.arguments[0])) {
      return b = graphql.valueFromASTUntyped(f.arguments[0].value, b), "include" === a ? !!b : !b;
    }
  }
  return !0;
}, buildClientSchema = function(a) {
  function b(a) {
    return {
      name: a.name,
      type: a.type,
      args: d(a.args)
    };
  }
  var c, d, e, f, g, h;
  a = a.__schema;
  for (c = {}, d = _ref, e = function(a) {
    switch (a.kind) {
     case "OBJECT":
     case "INTERFACE":
      return {
        name: a.name,
        kind: a.kind,
        interfaces: d(a.interfaces || []),
        fields: d(a.fields.map(b))
      };

     case "UNION":
      return {
        name: a.name,
        kind: a.kind,
        types: d(a.possibleTypes || [])
      };
    }
  }, f = 0; f < a.types.length; f++) {
    if ((g = a.types[f]) && g.name) {
      (h = e(g)) && (c[g.name] = h);
    }
  }
  return {
    query: a.queryType ? a.queryType.name : null,
    mutation: a.mutationType ? a.mutationType.name : null,
    subscription: a.subscriptionType ? a.subscriptionType.name : null,
    types: c,
    isSubType: function(a, b) {
      var d = c[a], e = c[b];
      return d && e ? "UNION" === d.kind ? !!d.types[b] : "OBJECT" !== d.kind && "OBJECT" === e.kind ? !!e.interfaces[a] : a === b : !1;
    }
  };
}, BUILTIN_FIELD_RE = /^__/, isFieldNullable = function(a, b, c) {
  if (BUILTIN_FIELD_RE.test(c)) {
    return !0;
  }
  return !!(a = getField(a, b, c)) && "NON_NULL" !== a.type.kind;
}, isListNullable = function(a, b, c) {
  if (!(a = getField(a, b, c))) {
    return !1;
  }
  return "LIST" === (a = "NON_NULL" === a.type.kind ? a.type.ofType : a.type).kind && "NON_NULL" !== a.ofType.kind;
}, isFieldAvailableOnType = function(a, b, c) {
  return BUILTIN_FIELD_RE.test(c) ? !0 : !!getField(a, b, c);
}, isInterfaceOfType = function(a, b, c) {
  if (!c) {
    return !1;
  }
  if (!(b = getTypeCondition(b)) || c === b) {
    return !0;
  }
  if (a.types[b] && "OBJECT" === a.types[b].kind) {
    return b === c;
  }
  !function expectAbstractType(a, b) {
    invariant(a.types[b] && ("INTERFACE" === a.types[b].kind || "UNION" === a.types[b].kind), "production" !== process.env.NODE_ENV ? "Invalid Abstract type: The type `" + b + "` is not an Interface or Union type in the defined schema, but a fragment in the GraphQL document is using it as a type condition." : "", 5);
  }(a, b);
  expectObjectType(a, c);
  return a.isSubType(b, c);
}, getField = function(a, b, c) {
  expectObjectType(a, b);
  a = a.types[b].fields[c];
  "production" !== process.env.NODE_ENV && (a || warn("Invalid field: The field `" + c + "` does not exist on `" + b + "`, but the GraphQL document expects it to exist.\nTraversal will continue, however this may lead to undefined behavior!", 4));
  return a;
}, keyOfField = function(a, b) {
  return b ? a + "(" + core.stringifyVariables(b) + ")" : a;
}, joinKeys = function(a, b) {
  return a + "." + b;
}, fieldInfoOfKey = function(a) {
  var b = a.indexOf("(");
  return -1 < b ? {
    fieldKey: a,
    fieldName: a.slice(0, b),
    arguments: JSON.parse(a.slice(b + 1, -1))
  } : {
    fieldKey: a,
    fieldName: a,
    arguments: null
  };
}, serializeKeys = function(a, b) {
  return a.replace(/\./g, "%2e") + "." + b;
}, deserializeKeyInfo = function(a) {
  var b = a.indexOf(".");
  return {
    entityKey: a.slice(0, b).replace(/%2e/g, "."),
    fieldKey: a = a.slice(b + 1)
  };
}, makeDict = function() {
  return Object.create(null);
}, isDictEmpty = function(a) {
  for (var b in a) {
    return !1;
  }
  return !0;
}, currentOperation = null, currentData = null, currentDependencies = null, currentOptimisticKey = null, currentOptimistic = !1, makeNodeMap = function() {
  return {
    optimistic: makeDict(),
    base: new Map
  };
}, initDataState = function(a, b, c, d) {
  currentOperation = a;
  currentData = b;
  currentDependencies = makeDict();
  currentOptimistic = !!d;
  "production" !== process.env.NODE_ENV && (currentDebugStack.length = 0);
  c ? d || 0 < b.optimisticOrder.length ? (d || b.commutativeKeys.has(c) ? d && b.commutativeKeys.delete(c) : reserveLayer(b, c), 
  currentOptimisticKey = c, createLayer(b, c)) : (currentOptimisticKey = null, deleteLayer(b, c)) : currentOptimisticKey = null;
}, clearDataState = function() {
  "production" !== process.env.NODE_ENV && getCurrentDependencies();
  var b = currentData, c = currentOptimisticKey;
  currentOptimistic = !1;
  currentOptimisticKey = null;
  if (c && -1 < b.optimisticOrder.indexOf(c)) {
    for (c = b.optimisticOrder.length; 0 <= --c && b.refLock[b.optimisticOrder[c]] && b.commutativeKeys.has(b.optimisticOrder[c]); ) {
      squashLayer(b.optimisticOrder[c]);
    }
  }
  currentDependencies = currentData = currentOperation = null;
  "production" !== process.env.NODE_ENV && (currentDebugStack.length = 0);
  "test" === process.env.NODE_ENV || b.defer || (b.defer = !0, Promise.resolve().then((function a() {
    initDataState("read", b, null);
    gc();
    persistData();
    clearDataState();
    b.defer = !1;
  })));
}, noopDataState = function(a, b, c) {
  initDataState("read", a, b, c);
  clearDataState();
}, getCurrentOperation = function() {
  invariant(null !== currentOperation, "production" !== process.env.NODE_ENV ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return currentOperation;
}, getCurrentDependencies = function() {
  invariant(null !== currentDependencies, "production" !== process.env.NODE_ENV ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return currentDependencies;
}, make = function(a) {
  return {
    defer: !1,
    gc: new Set,
    persist: new Set,
    queryRootKey: a,
    refCount: makeDict(),
    refLock: makeDict(),
    links: makeNodeMap(),
    records: makeNodeMap(),
    commutativeKeys: new Set,
    optimisticOrder: [],
    storage: null
  };
}, setNode = function(a, b, c, d) {
  var e = (a = currentOptimisticKey ? a.optimistic[currentOptimisticKey] : a.base).get(b);
  void 0 === e && a.set(b, e = makeDict());
  void 0 !== d || currentOptimisticKey ? e[c] = d : delete e[c];
}, getNode = function(a, b, c) {
  var d, e, f, g, h, k;
  for (e = !currentOptimistic && "read" === currentOperation && currentOptimisticKey && currentData.commutativeKeys.has(currentOptimisticKey), 
  f = 0, g = currentData.optimisticOrder.length; f < g; f++) {
    h = currentData.optimisticOrder[f];
    e = e && h !== currentOptimisticKey;
    if (!(!(k = a.optimistic[h]) || e && currentData.commutativeKeys.has(h) || currentOptimistic && "write" !== currentOperation && !currentData.commutativeKeys.has(h)) && void 0 !== (d = k.get(b)) && c in d) {
      return d[c];
    }
  }
  return void 0 !== (d = a.base.get(b)) ? d[c] : void 0;
}, updateRCForEntity = function(a, b, c, d) {
  var e = void 0 !== b[c] ? b[c] : 0;
  b = b[c] = e + d | 0;
  void 0 !== a && (0 >= b ? a.add(c) : 0 >= e && 0 < b && a.delete(c));
}, updateRCForLink = function(a, b, c, d) {
  var e, f, g;
  if ("string" == typeof c) {
    updateRCForEntity(a, b, c, d);
  } else if (Array.isArray(c)) {
    for (e = 0, f = c.length; e < f; e++) {
      (g = c[e]) && updateRCForEntity(a, b, g, d);
    }
  }
}, extractNodeFields = function(a, b, c) {
  if (void 0 !== c) {
    for (var d in c) {
      b.has(d) || (a.push(fieldInfoOfKey(d)), b.add(d));
    }
  }
}, extractNodeMapFields = function(a, b, c, d) {
  var e, f, g;
  extractNodeFields(a, b, d.base.get(c));
  for (e = 0, f = currentData.optimisticOrder.length; e < f; e++) {
    void 0 !== (g = d.optimistic[currentData.optimisticOrder[e]]) && extractNodeFields(a, b, g.get(c));
  }
}, gc = function() {
  currentData.gc.forEach(_ref2);
}, updateDependencies = function(a, b) {
  "__typename" !== b && (a !== currentData.queryRootKey ? currentDependencies[a] = !0 : void 0 !== b && (currentDependencies[joinKeys(a, b)] = !0));
}, updatePersist = function(a, b) {
  !currentOptimistic && currentData.storage && currentData.persist.add(serializeKeys(a, b));
}, readRecord = function(a, b) {
  updateDependencies(a, b);
  return getNode(currentData.records, a, b);
}, readLink = function(a, b) {
  updateDependencies(a, b);
  return getNode(currentData.links, a, b);
}, writeRecord = function(a, b, c) {
  updateDependencies(a, b);
  updatePersist(a, b);
  setNode(currentData.records, a, b, c);
}, hasField = function(a, b) {
  return void 0 !== readRecord(a, b) || void 0 !== readLink(a, b);
}, writeLink = function(a, b, c) {
  var e, f, g, d = currentData;
  if (currentOptimisticKey) {
    e = d.refLock[currentOptimisticKey] || (d.refLock[currentOptimisticKey] = makeDict());
    f = d.links.optimistic[currentOptimisticKey];
  } else {
    e = d.refCount;
    f = d.links.base;
    g = d.gc;
  }
  f = (f = f && f.get(a)) && f[b];
  updateDependencies(a, b);
  updatePersist(a, b);
  setNode(d.links, a, b, c);
  updateRCForLink(g, e, f, -1);
  updateRCForLink(g, e, c, 1);
}, reserveLayer = function(a, b) {
  var c = a.optimisticOrder.indexOf(b);
  -1 === c ? a.optimisticOrder.unshift(b) : a.commutativeKeys.has(b) || (clearLayer(a, b), 
  a.optimisticOrder.splice(c, 1), a.optimisticOrder.unshift(b));
  a.commutativeKeys.add(b);
}, createLayer = function(a, b) {
  -1 === a.optimisticOrder.indexOf(b) && a.optimisticOrder.unshift(b);
  a.refLock[b] || (a.refLock[b] = makeDict(), a.links.optimistic[b] = new Map, a.records.optimistic[b] = new Map);
}, clearLayer = function(a, b) {
  a.refLock[b] && (delete a.refLock[b], delete a.records.optimistic[b], delete a.links.optimistic[b]);
}, deleteLayer = function(a, b) {
  var c = a.optimisticOrder.indexOf(b);
  -1 < c && (a.optimisticOrder.splice(c, 1), a.commutativeKeys.delete(b));
  clearLayer(a, b);
}, squashLayer = function(a) {
  var c, b = currentDependencies;
  currentDependencies = makeDict();
  (c = currentData.links.optimistic[a]) && c.forEach(_ref3);
  (c = currentData.records.optimistic[a]) && c.forEach(_ref4);
  currentDependencies = b;
  deleteLayer(currentData, a);
}, inspectFields = function(a) {
  var b = currentData.links, c = currentData.records, d = [], e = new Set;
  updateDependencies(a);
  extractNodeMapFields(d, e, a, b);
  extractNodeMapFields(d, e, a, c);
  return d;
}, persistData = function() {
  if (currentData.storage) {
    currentOptimistic = !0;
    currentOperation = "read";
    var b = makeDict();
    currentData.persist.forEach((function a(a) {
      var f, c = deserializeKeyInfo(a), e = c.entityKey;
      void 0 !== (f = readLink(e, c = c.fieldKey)) ? b[a] = ":" + core.stringifyVariables(f) : void 0 !== (f = readRecord(e, c)) ? b[a] = core.stringifyVariables(f) : b[a] = void 0;
    }));
    currentOptimistic = !1;
    currentData.storage.writeData(b);
    currentData.persist.clear();
  }
}, hydrateData = function(a, b, c) {
  var d, e, f, g;
  initDataState("write", a, null);
  for (d in c) {
    if (void 0 !== (e = c[d])) {
      g = (f = deserializeKeyInfo(d)).entityKey;
      f = f.fieldKey;
      ":" === e[0] ? writeLink(g, f, JSON.parse(e.slice(1))) : writeRecord(g, f, JSON.parse(e));
    }
  }
  clearDataState();
  a.storage = b;
}, contextRef = {
  current: null
}, makeContext = function(a, b, c, d, e, f) {
  return {
    store: a,
    variables: b,
    fragments: c,
    parent: {
      __typename: d
    },
    parentTypeName: d,
    parentKey: e,
    parentFieldKey: "",
    fieldName: "",
    partial: !1,
    optimistic: !!f
  };
}, updateContext = function(a, b, c, d, e, f) {
  contextRef.current = a;
  a.parent = b;
  a.parentTypeName = c;
  a.parentKey = d;
  a.parentFieldKey = e;
  a.fieldName = f;
}, isFragmentHeuristicallyMatching = function(a, b, c, d) {
  if (!b) {
    return !1;
  }
  var e = getTypeCondition(a);
  if (!e || b === e) {
    return !0;
  }
  "production" !== process.env.NODE_ENV && warn("Heuristic Fragment Matching: A fragment is trying to match against the `" + b + "` type, but the type condition is `" + e + "`. Since GraphQL allows for interfaces `" + e + "` may be aninterface.\nA schema needs to be defined for this match to be deterministic, otherwise the fragment will be matched heuristically!", 16);
  return !getSelectionSet(a).some((function(a) {
    if (!isFieldNode(a)) {
      return !1;
    }
    a = keyOfField(getName(a), getFieldArguments(a, d));
    return !hasField(c, a);
  }));
}, makeSelectionIterator = function(a, b, c, d) {
  var e, f = 0;
  return function() {
    if (void 0 !== e) {
      var g = e();
      if (void 0 !== g) {
        return g;
      }
      e = void 0;
      "production" !== process.env.NODE_ENV && popDebugNode();
    }
    for (;f < c.length; ) {
      if (g = c[f++], shouldInclude(g, d.variables)) {
        if (isFieldNode(g)) {
          return g;
        }
        if (void 0 !== (g = isInlineFragment(g) ? g : d.fragments[getName(g)]) && (d.store.schema ? isInterfaceOfType(d.store.schema, g, a) : isFragmentHeuristicallyMatching(g, a, b, d.variables))) {
          return "production" !== process.env.NODE_ENV && pushDebugNode(a, g), (e = makeSelectionIterator(a, b, getSelectionSet(g), d))();
        }
      }
    }
  };
}, ensureData = function(a) {
  return void 0 === a ? null : a;
}, write = function(a, b, c, d) {
  initDataState("write", a.data, d || null);
  a = startWrite(a, b, c);
  clearDataState();
  return a;
}, startWrite = function(a, b, c) {
  var d = getMainOperation(b.query), e = {
    data: c,
    dependencies: getCurrentDependencies()
  }, f = a.rootFields[d.operation];
  a = makeContext(a, normalizeVariables(d, b.variables), getFragments(b.query), f, f);
  "production" !== process.env.NODE_ENV && pushDebugNode(f, d);
  writeSelection(a, f, getSelectionSet(d), c);
  "production" !== process.env.NODE_ENV && popDebugNode();
  return e;
}, writeOptimistic = function(a, b, c) {
  initDataState("write", a.data, c, !0);
  c = getMainOperation(b.query);
  var d = {
    data: {},
    dependencies: getCurrentDependencies()
  }, e = a.rootFields[c.operation];
  invariant(e === a.rootFields.mutation, "production" !== process.env.NODE_ENV ? "writeOptimistic(...) was called with an operation that is not a mutation.\nThis case is unsupported and should never occur." : "", 10);
  "production" !== process.env.NODE_ENV && pushDebugNode(e, c);
  a = makeContext(a, normalizeVariables(c, b.variables), getFragments(b.query), e, e, !0);
  writeSelection(a, e, getSelectionSet(c), d.data);
  "production" !== process.env.NODE_ENV && popDebugNode();
  clearDataState();
  return d;
}, writeFragment = function(a, b, c, d) {
  var e, f, g;
  if (!(e = (b = getFragments(b))[(e = Object.keys(b))[0]])) {
    return "production" !== process.env.NODE_ENV ? warn("writeFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 11) : void 0;
  }
  f = getFragmentTypeName(e);
  c = _rollupPluginBabelHelpers._extends({}, {
    __typename: f
  }, c);
  if (!(g = a.keyOfEntity(c))) {
    return "production" !== process.env.NODE_ENV ? warn("Can't generate a key for writeFragment(...) data.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + f + "`.", 12) : void 0;
  }
  "production" !== process.env.NODE_ENV && pushDebugNode(f, e);
  a = makeContext(a, d || {}, b, f, g);
  writeSelection(a, g, getSelectionSet(e), c);
  "production" !== process.env.NODE_ENV && popDebugNode();
}, writeSelection = function(a, b, c, d) {
  var h, k, m, r, l, e = b === a.store.rootFields.query, f = !e && !!a.store.rootNames[b], g = f || e ? b : d.__typename;
  if (g) {
    f || e || !b || writeRecord(b, "__typename", g);
    c = makeSelectionIterator(g, b || g, c, a);
    for (;h = c(); ) {
      k = getName(h), m = getFieldArguments(h, a.variables);
      e = keyOfField(k, m);
      l = d[r = getFieldAlias(h)];
      if ("production" !== process.env.NODE_ENV) {
        if (f || void 0 !== l) {
          a.store.schema && g && "__typename" !== k && isFieldAvailableOnType(a.store.schema, g, k);
        } else {
          k = a.optimistic ? "\nYour optimistic result may be missing a field!" : "";
          m = void 0 === h.selectionSet ? "scalar (number, boolean, etc)" : "selection set";
          "production" !== process.env.NODE_ENV && warn("Invalid undefined: The field at `" + e + "` is `undefined`, but the GraphQL query expects a " + m + " for this field." + k, 13);
          continue;
        }
      }
      if ("__typename" !== k) {
        if (a.optimistic && f) {
          if (!(l = a.store.optimisticMutations[k])) {
            continue;
          }
          updateContext(a, d, g, g, e, k);
          l = d[r] = ensureData(l(m || {}, a.store, a));
        }
        h.selectionSet ? b && !f ? (r = joinKeys(b, e), h = writeField(a, getSelectionSet(h), ensureData(l), r), 
        writeLink(b || g, e, h)) : writeField(a, getSelectionSet(h), ensureData(l)) : b && !f && writeRecord(b || g, e, l);
        f && (updateContext(a, d, g, g, joinKeys(g, e), k), e = a.store.updates[g][k]) && (d[k] = l, 
        e(d, m || {}, a.store, a));
      }
    }
  } else {
    "production" !== process.env.NODE_ENV && warn("Couldn't find __typename when writing.\nIf you're writing to the cache manually have to pass a `__typename` property on each entity in your data.", 14);
  }
}, KEYLESS_TYPE_RE = /^__|PageInfo|(Connection|Edge)$/, writeField = function(a, b, c, d) {
  var e, f, g, h, k;
  if (Array.isArray(c)) {
    for (e = Array(c.length), f = 0, g = c.length; f < g; f++) {
      h = c[f], k = d ? joinKeys(d, "" + f) : void 0;
      h = writeField(a, b, h, k);
      e[f] = h;
    }
    return e;
  }
  if (null === c) {
    return null;
  }
  e = a.store.keyOfEntity(c);
  f = c.__typename;
  "production" !== process.env.NODE_ENV && (!d || a.store.keys[c.__typename] || null !== e || "string" != typeof f || KEYLESS_TYPE_RE.test(f) || warn("Invalid key: The GraphQL query at the field at `" + d + "` has a selection set, but no key could be generated for the data at this field.\nYou have to request `id` or `_id` fields for all selection sets or create a custom `keys` config for `" + f + "`.\nEntities without keys will be embedded directly on the parent entity. If this is intentional, create a `keys` config for `" + f + "` that always returns null.", 15));
  writeSelection(a, d = e || d, b, c);
  return d || null;
}, invalidateEntity = function(a, b, c) {
  var d, e;
  b = b ? [ {
    fieldKey: keyOfField(b, c)
  } ] : inspectFields(a);
  c = 0;
  for (d = b.length; c < d; c++) {
    void 0 !== readLink(a, e = b[c].fieldKey) ? writeLink(a, e, void 0) : writeRecord(a, e, void 0);
  }
}, Store = function(a) {
  var b, c, d, e, f, g;
  this.keyOfField = keyOfField;
  this.resolveFieldByKey = this.resolve;
  a || (a = {});
  this.resolvers = a.resolvers || {};
  this.optimisticMutations = a.optimistic || {};
  this.keys = a.keys || {};
  d = "Query", e = "Mutation", f = "Subscription";
  if (a.schema) {
    d = (g = this.schema = buildClientSchema(a.schema)).query || d;
    e = g.mutation || e;
    f = g.subscription || f;
  }
  this.updates = ((b = {})[e] = a.updates && a.updates.Mutation || {}, b[f] = a.updates && a.updates.Subscription || {}, 
  b);
  this.rootFields = {
    query: d,
    mutation: e,
    subscription: f
  };
  this.rootNames = ((c = {})[d] = "query", c[e] = "mutation", c[f] = "subscription", 
  c);
  this.data = make(d);
  this.schema && "production" !== process.env.NODE_ENV && (function expectValidKeyingConfig(a, b) {
    if ("production" !== process.env.NODE_ENV) {
      for (var c in b) {
        "production" !== process.env.NODE_ENV && (a.types[c] || warn("Invalid Object type: The type `" + c + "` is not an object in the defined schema, but the `keys` option is referencing it.", 20));
      }
    }
  }(this.schema, this.keys), function expectValidUpdatesConfig(a, b) {
    var c, d, e, f;
    if ("production" !== process.env.NODE_ENV) {
      if (a.mutation) {
        c = a.types[a.mutation].fields, d = b[a.mutation] || {};
        for (e in d) {
          "production" !== process.env.NODE_ENV && void 0 === c[e] && warn("Invalid mutation field: `" + e + "` is not in the defined schema, but the `updates.Mutation` option is referencing it.", 21);
        }
      }
      if (a.subscription) {
        c = a.types[a.subscription].fields;
        a = b[a.subscription] || {};
        for (f in a) {
          "production" !== process.env.NODE_ENV && void 0 === c[f] && warn("Invalid subscription field: `" + f + "` is not in the defined schema, but the `updates.Subscription` option is referencing it.", 22);
        }
      }
    }
  }(this.schema, this.updates), function expectValidResolversConfig(a, b) {
    var c, d, e, f;
    if ("production" !== process.env.NODE_ENV) {
      for (c in b) {
        if ("Query" === c) {
          if (a.query) {
            d = a.types[a.query].fields;
            for (e in b.Query) {
              d[e] || warnAboutResolver("Query." + e);
            }
          } else {
            warnAboutResolver("Query");
          }
        } else if (a.types[c]) {
          if ("INTERFACE" === a.types[c].kind || "UNION" === a.types[c].kind) {
            warnAboutAbstractResolver(c, a.types[c].kind);
          } else {
            d = a.types[c].fields;
            for (f in b[c]) {
              d[f] || warnAboutResolver(c + "." + f);
            }
          }
        } else {
          warnAboutResolver(c);
        }
      }
    }
  }(this.schema, this.resolvers), function expectValidOptimisticMutationsConfig(a, b) {
    if ("production" !== process.env.NODE_ENV && a.mutation) {
      a = a.types[a.mutation].fields;
      for (var c in b) {
        "production" !== process.env.NODE_ENV && (a[c] || warn("Invalid optimistic mutation field: `" + c + "` is not a mutation field in the defined schema, but the `optimistic` option is referencing it.", 24));
      }
    }
  }(this.schema, this.optimisticMutations));
};

Store.prototype.keyOfEntity = function(a) {
  if (contextRef.current && a === contextRef.current.parent) {
    return contextRef.current.parentKey;
  }
  if (null == a || "string" == typeof a) {
    return a || null;
  }
  if (!a.__typename) {
    return null;
  }
  if (this.rootNames[a.__typename]) {
    return a.__typename;
  }
  var b;
  this.keys[a.__typename] ? b = this.keys[a.__typename](a) : null != a.id ? b = "" + a.id : null != a._id && (b = "" + a._id);
  return b ? a.__typename + ":" + b : null;
};

Store.prototype.resolve = function(a, b, c) {
  b = keyOfField(b, c);
  if (!(a = this.keyOfEntity(a))) {
    return null;
  }
  return void 0 !== (c = readRecord(a, b)) ? c : readLink(a, b) || null;
};

Store.prototype.invalidate = function(a, b, c) {
  var d = this.keyOfEntity(a);
  invariant(d, "production" !== process.env.NODE_ENV ? "object" == "Can't generate a key for invalidate(...).\nYou have to pass an id or _id field or create a custom `keys` field for `" + typeof a ? a.__typename : a + "`." : "", 19);
  invalidateEntity(d, b, c);
};

Store.prototype.inspectFields = function(a) {
  return (a = this.keyOfEntity(a)) ? inspectFields(a) : [];
};

Store.prototype.updateQuery = function(a, b) {
  (a = core.createRequest(a.query, a.variables)).query = core.formatDocument(a.query);
  null !== (b = b(this.readQuery(a))) && startWrite(this, a, b);
};

Store.prototype.readQuery = function(a) {
  (a = core.createRequest(a.query, a.variables)).query = core.formatDocument(a.query);
  return read(this, a).data;
};

Store.prototype.readFragment = function(a, b, c) {
  return readFragment(this, core.formatDocument(a), b, c);
};

Store.prototype.writeFragment = function(a, b, c) {
  writeFragment(this, core.formatDocument(a), b, c);
};

query = function(a, b, c, d) {
  initDataState("read", a.data, c && d || null);
  a = read(a, b, c);
  clearDataState();
  return a;
}, read = function(a, b, c) {
  var d = getMainOperation(b.query), e = a.rootFields[d.operation], f = getSelectionSet(d);
  a = makeContext(a, normalizeVariables(d, b.variables), getFragments(b.query), e, e);
  "production" !== process.env.NODE_ENV && pushDebugNode(e, d);
  c = e !== a.store.rootFields.query ? readRoot(a, e, f, c || {}) : readSelection(a, e, f, {});
  "production" !== process.env.NODE_ENV && popDebugNode();
  return {
    dependencies: getCurrentDependencies(),
    partial: a.partial || !c,
    data: c || null
  };
}, readRoot = function(a, b, c, d) {
  var e, f, g;
  if ("string" != typeof d.__typename) {
    return d;
  }
  b = makeSelectionIterator(b, b, c, a);
  (c = {}).__typename = d.__typename;
  for (;e = b(); ) {
    g = d[f = getFieldAlias(e)];
    e.selectionSet && null !== g ? (g = ensureData(g), c[f] = readRootField(a, getSelectionSet(e), g)) : c[f] = g;
  }
  return c;
}, readRootField = function(a, b, c) {
  if (Array.isArray(c)) {
    for (var d = Array(c.length), e = 0, f = c.length; e < f; e++) {
      d[e] = readRootField(a, b, c[e]);
    }
    return d;
  }
  if (null === c) {
    return null;
  }
  return null !== (d = a.store.keyOfEntity(c)) ? void 0 === (a = readSelection(a, d, b, {})) ? null : a : readRoot(a, c.__typename, b, c);
}, readFragment = function(a, b, c, d) {
  var e, f;
  if (!(e = (b = getFragments(b))[(e = Object.keys(b))[0]])) {
    return "production" !== process.env.NODE_ENV && warn("readFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 6), 
    null;
  }
  f = getFragmentTypeName(e);
  "string" == typeof c || c.__typename || (c.__typename = f);
  if (!(c = a.keyOfEntity(c))) {
    return "production" !== process.env.NODE_ENV && warn("Can't generate a key for readFragment(...).\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + f + "`.", 7), 
    null;
  }
  "production" !== process.env.NODE_ENV && pushDebugNode(f, e);
  a = makeContext(a, d || {}, b, f, c);
  a = readSelection(a, c, getSelectionSet(e), {}) || null;
  "production" !== process.env.NODE_ENV && popDebugNode();
  return a;
}, readSelection = function(a, b, c, d, e) {
  var k, m, r, l, w, p, x, t, n, u, v, q, f = a.store, g = b === f.rootFields.query, h = e && f.keyOfEntity(e) || b;
  "production" !== process.env.NODE_ENV && !g && a.store.rootNames[h] && warn("Invalid root traversal: A selection was being read on `" + h + "` which is an uncached root type.\nThe `" + a.store.rootFields.mutation + "` and `" + a.store.rootFields.subscription + "` types are special Operation Root Types and cannot be read back from the cache.", 25);
  if ("string" == typeof (b = g ? b : readRecord(h, "__typename") || e && e.__typename)) {
    if (e && b !== e.__typename) {
      "production" !== process.env.NODE_ENV && warn("Invalid resolver data: The resolver at `" + h + "` returned an invalid typename that could not be reconciled with the cache.", 8);
    } else {
      c = makeSelectionIterator(b, h, c, a);
      for (m = !1, r = !1; void 0 !== (k = c()); ) {
        l = getName(k), w = getFieldArguments(k, a.variables), p = getFieldAlias(k), x = keyOfField(l, w), 
        t = joinKeys(h, x), n = readRecord(h, x), u = e ? e[l] : void 0, v = f.resolvers[b];
        "production" !== process.env.NODE_ENV && f.schema && b && isFieldAvailableOnType(f.schema, b, l);
        q = void 0;
        if ("__typename" === l) {
          d[p] = b;
        } else {
          if (void 0 !== u && void 0 === k.selectionSet) {
            q = u;
          } else if ("read" === getCurrentOperation() && v && "function" == typeof v[l]) {
            if (updateContext(a, d, b, h, t, l), void 0 !== n && (d[p] = n), q = v[l](d, w || {}, f, a), 
            k.selectionSet && (q = resolveResolverResult(a, b, l, t, getSelectionSet(k), d[p], q)), 
            f.schema && null === q && !isFieldNullable(f.schema, b, l)) {
              return;
            }
          } else {
            k.selectionSet ? void 0 !== u ? q = resolveResolverResult(a, b, l, t, getSelectionSet(k), d[p], u) : void 0 !== (w = readLink(h, x)) ? q = resolveLink(a, w, b, l, getSelectionSet(k), d[p]) : "object" == typeof n && null !== n && (q = n) : q = n;
          }
          if (void 0 === q && f.schema && isFieldNullable(f.schema, b, l)) {
            r = !0, d[p] = null;
          } else {
            if (void 0 === q) {
              return;
            }
            m = !0;
            d[p] = q;
          }
        }
      }
      r && (a.partial = !0);
      return g && r && !m ? void 0 : d;
    }
  }
}, resolveResolverResult = function(a, b, c, d, e, f, g) {
  var h, k, m, r, l;
  if (Array.isArray(g)) {
    h = !(h = a.store).schema || isListNullable(h.schema, b, c);
    for (k = Array(g.length), m = 0, r = g.length; m < r; m++) {
      if (void 0 !== (l = resolveResolverResult(a, b, c, joinKeys(d, "" + m), e, null != f ? f[m] : void 0, g[m])) || h) {
        k[m] = void 0 !== l ? l : null;
      } else {
        return;
      }
    }
    return k;
  }
  if (null == g) {
    return g;
  }
  if (null === f) {
    return null;
  }
  if (isDataOrKey(g)) {
    return b = f || {}, "string" == typeof g ? readSelection(a, g, e, b) : readSelection(a, d, e, b, g);
  }
  "production" !== process.env.NODE_ENV && warn("Invalid resolver value: The field at `" + d + "` is a scalar (number, boolean, etc), but the GraphQL query expects a selection set for this field.", 9);
}, resolveLink = function(a, b, c, d, e, f) {
  var g, h, k, m, r;
  if (Array.isArray(b)) {
    g = (g = a.store).schema && isListNullable(g.schema, c, d);
    for (h = Array(b.length), k = 0, m = b.length; k < m; k++) {
      if (void 0 !== (r = resolveLink(a, b[k], c, d, e, null != f ? f[k] : void 0)) || g) {
        h[k] = void 0 !== r ? r : null;
      } else {
        return;
      }
    }
    return h;
  }
  return null === b || null === f ? null : readSelection(a, b, e, f || {});
}, isDataOrKey = function(a) {
  return "string" == typeof a || "object" == typeof a && "string" == typeof a.__typename;
}, addCacheOutcome = function(a, b) {
  return core.makeOperation(a.kind, a, _rollupPluginBabelHelpers._extends({}, a.context, {
    meta: _rollupPluginBabelHelpers._extends({}, a.context.meta, {
      cacheOutcome: b
    })
  }));
}, toRequestPolicy = function(a, b) {
  return core.makeOperation(a.kind, a, _rollupPluginBabelHelpers._extends({}, a.context, {
    requestPolicy: b
  }));
};

cacheExchange = function(a) {
  return function(b) {
    function d(a) {
      "production" !== process.env.NODE_ENV && w({
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache",
        operation: a.operation,
        source: "cacheExchange"
      });
      return addCacheOutcome(a.operation, "miss");
    }
    function e(a) {
      return "miss" === a.outcome && "cache-only" !== a.operation.context.requestPolicy && !B(a.dependencies);
    }
    function f(a) {
      var b = a.operation, c = a.outcome, d = a.dependencies, e = {
        operation: addCacheOutcome(b, c),
        data: a.data,
        error: a.error,
        extensions: a.extensions
      };
      if ("cache-and-network" === b.context.requestPolicy || "cache-first" === b.context.requestPolicy && "partial" === c) {
        e.stale = !0, B(d) ? "cache-and-network" === b.context.requestPolicy && q.add(b.key) : l.reexecuteOperation(toRequestPolicy(b, "network-only"));
      }
      "production" !== process.env.NODE_ENV && w({
        type: "cacheHit",
        message: "A requested operation was found and returned from the cache.",
        operation: a.operation,
        data: {
          value: e
        },
        source: "cacheExchange"
      });
      return e;
    }
    function g(a) {
      var b = new Set, c = C(a, b);
      A(a.operation, b);
      return c;
    }
    function h(a) {
      return !t.has(a.operation.key);
    }
    function k(a) {
      var b, c, d;
      if (n.push(a) < t.size) {
        return wonka.empty;
      }
      for (b = 0; b < n.length; b++) {
        reserveLayer(p.data, n[b].operation.key);
      }
      for (c in v) {
        delete v[c];
      }
      b = [];
      c = new Set;
      for (;d = n.shift(); ) {
        b.push(C(d, c));
      }
      A(a.operation, c);
      return wonka.fromArray(b);
    }
    function m(a) {
      return t.has(a.operation.key);
    }
    var x, t, n, u, v, q, y, B, z, A, E, D, F, C, r = b.forward, l = b.client, w = b.dispatchDebug, p = new Store(a);
    a && a.storage && (x = a.storage.readData().then((function c(b) {
      hydrateData(p.data, a.storage, b);
    })));
    t = new Map, n = [], u = new Map, v = makeDict(), q = new Set, y = makeDict(), B = function(a) {
      for (var b in a) {
        if (v[b]) {
          return !0;
        }
      }
      return !1;
    }, z = function(a, b) {
      var c, d, e;
      if (b) {
        for (c in b) {
          if (b = y[c]) {
            y[c] = [];
            for (d = 0, e = b.length; d < e; d++) {
              a.add(b[d]);
            }
          }
        }
      }
    }, A = function(a, b) {
      b.forEach((function(b) {
        var c, d;
        if (b !== a.key) {
          if (c = u.get(b)) {
            u.delete(b);
            d = "cache-first";
            q.has(b) && (q.delete(b), d = "cache-and-network");
            l.reexecuteOperation(toRequestPolicy(c, d));
          }
        }
      }));
    }, E = function(a) {
      var b, c;
      if ("query" === a.kind) {
        reserveLayer(p.data, a.key);
      } else if ("teardown" === a.kind) {
        u.delete(a.key), noopDataState(p.data, a.key);
      } else if ("mutation" === a.kind && "network-only" !== a.context.requestPolicy) {
        b = writeOptimistic(p, a, a.key).dependencies;
        if (!isDictEmpty(b)) {
          for (c in b) {
            v[c] = !0;
          }
          t.set(a.key, b);
          c = new Set;
          z(c, b);
          A(a, c);
        }
      }
      return core.makeOperation(a.kind, {
        key: a.key,
        query: core.formatDocument(a.query),
        variables: a.variables ? filterVariables(getMainOperation(a.query), a.variables) : a.variables
      }, a.context);
    }, D = function(a, b) {
      for (var c in b) {
        (y[c] || (y[c] = [])).push(a.key), u.set(a.key, a);
      }
    }, F = function(a) {
      var b = query(p, a), c = b.data ? b.partial ? "partial" : "hit" : "miss";
      D(a, b.dependencies);
      return {
        outcome: c,
        operation: a,
        data: b.data,
        dependencies: b.dependencies
      };
    }, C = function(a, b) {
      var g, h, c = a.operation, d = a.error, e = a.extensions, f = c.key;
      if ("mutation" === c.kind) {
        g = t.get(f);
        z(b, g);
        t.delete(f);
      } else {
        reserveLayer(p.data, c.key);
      }
      if (a.data) {
        if (g = write(p, c, a.data, f).dependencies, z(b, g), f = query(p, c, a.data, f), 
        a.data = f.data, "query" === c.kind) {
          z(b, h = f.dependencies);
        }
      } else {
        noopDataState(p.data, c.key);
      }
      h && D(a.operation, h);
      return {
        data: a.data,
        error: d,
        extensions: e,
        operation: c
      };
    };
    return function(a) {
      var b, c;
      a = wonka.share(a);
      b = x ? wonka.mergeMap(_ref2$1)(wonka.take(1)(wonka.combine(wonka.scan(_ref3$1, [])(a), wonka.fromPromise(x)))) : wonka.empty;
      b = wonka.share(wonka.concat([ b, a ]));
      a = wonka.share(wonka.map(F)(wonka.filter(_ref4$1)(b)));
      b = wonka.filter(_ref5)(b);
      c = wonka.map(d)(wonka.filter(e)(a));
      a = wonka.map(f)(wonka.filter(_ref9)(a));
      c = wonka.share(r(wonka.map(E)(wonka.merge([ b, c ]))));
      b = wonka.map(g)(wonka.filter(h)(c));
      c = wonka.mergeMap(k)(wonka.filter(m)(c));
      return wonka.merge([ b, c, a ]);
    };
  };
}, isOptimisticMutation = function(a, b) {
  var e, c = b.variables || makeDict(), d = getFragments(b.query);
  b = [].concat(getSelectionSet(getMainOperation(b.query)));
  for (;e = b.pop(); ) {
    if (shouldInclude(e, c)) {
      if (!isFieldNode(e)) {
        (e = isInlineFragment(e) ? e : d[getName(e)]) && b.push.apply(b, getSelectionSet(e));
      } else if (a[getName(e)]) {
        return !0;
      }
    }
  }
  return !1;
}, isOfflineError = function(a) {
  return a && a.networkError && !a.response && ("undefined" != typeof navigator && !1 === navigator.onLine || /request failed|failed to fetch|network\s?error/i.test(a.networkError.message));
}, offlineExchange = function(a) {
  return function(b) {
    function e(a) {
      return "mutation" === a.operation.kind && isOfflineError(a.error) && isOptimisticMutation(t, a.operation) ? (n.push(a.operation), 
      u(), !1) : !0;
    }
    function h(a) {
      return "query" === a.operation.kind && isOfflineError(a.error) ? (x(toRequestPolicy(a.operation, "cache-only")), 
      n.push(a.operation), !1) : !0;
    }
    var r, l, w, p, x, t, n, u, v, q, y, m = a.storage;
    if (m && m.onOnline && m.readMetadata && m.writeMetadata) {
      r = b.forward, l = b.client;
      b = b.dispatchDebug;
      w = wonka.makeSubject(), p = w.source, x = w.next, t = a.optimistic || {}, n = [], 
      u = function c() {
        var a, b, c;
        for (a = [], b = 0; b < n.length; b++) {
          "mutation" === (c = n[b]).kind && a.push({
            query: graphql.print(c.query),
            variables: c.variables
          });
        }
        m.writeMetadata(a);
      }, v = !1;
      m.onOnline(q = function d() {
        var a, b;
        if (!v) {
          v = !0;
          for (a = 0; a < n.length; a++) {
            "mutation" === (b = n[a]).kind && x(core.makeOperation("teardown", b));
          }
          for (a = 0; a < n.length; a++) {
            l.reexecuteOperation(n[a]);
          }
          n.length = 0;
          v = !1;
          u();
        }
      });
      m.readMetadata().then((function g(a) {
        if (a) {
          for (var b = 0; b < a.length; b++) {
            n.push(l.createRequestOperation("mutation", core.createRequest(a[b].query, a[b].variables)));
          }
          q();
        }
      }));
      y = cacheExchange(a)({
        client: l,
        dispatchDebug: b,
        forward: function f(a) {
          return wonka.filter(e)(r(a));
        }
      });
      return function k(a) {
        a = wonka.share(a);
        a = wonka.merge([ p, a ]);
        return wonka.filter(h)(y(a));
      };
    }
    return cacheExchange(a)(b);
  };
};

exports.Store = Store;

exports.cacheExchange = cacheExchange;

exports.offlineExchange = offlineExchange;

exports.query = query;

exports.write = write;
//# sourceMappingURL=urql-exchange-graphcache.js.map
