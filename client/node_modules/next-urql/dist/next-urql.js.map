{"version":3,"file":"next-urql.js","sources":["../src/init-urql-client.ts","../src/with-urql-client.tsx"],"sourcesContent":["import { createClient, Client, ClientOptions } from 'urql';\nimport 'isomorphic-unfetch';\n\nlet urqlClient: Client | null = null;\n\nexport function resetClient() {\n  urqlClient = null;\n}\n\nexport function initUrqlClient(\n  clientOptions: ClientOptions,\n  canEnableSuspense: boolean\n): Client | null {\n  // Create a new Client for every server-side rendered request.\n  // This ensures we reset the state for each rendered page.\n  // If there is an exising client instance on the client-side, use it.\n  const isServer = typeof window === 'undefined';\n  if (isServer || !urqlClient) {\n    urqlClient = createClient({\n      ...clientOptions,\n      suspense: canEnableSuspense && (isServer || clientOptions.suspense),\n    });\n    // Serialize the urqlClient to null on the client-side.\n    // This ensures we don't share client and server instances of the urqlClient.\n    (urqlClient as any).toJSON = () => null;\n  }\n\n  // Return both the Client instance and the ssrCache.\n  return urqlClient;\n}\n","import React, { useState } from 'react';\nimport { NextPage, NextPageContext } from 'next';\nimport NextApp, { AppContext } from 'next/app';\nimport ssrPrepass from 'react-ssr-prepass';\nimport {\n  Provider,\n  ssrExchange,\n  dedupExchange,\n  cacheExchange,\n  fetchExchange,\n} from 'urql';\n\nimport { initUrqlClient, resetClient } from './init-urql-client';\nimport {\n  NextUrqlClientConfig,\n  NextUrqlContext,\n  WithUrqlProps,\n  WithUrqlClientOptions,\n} from './types';\n\nfunction getDisplayName(Component: React.ComponentType<any>) {\n  return Component.displayName || Component.name || 'Component';\n}\n\nlet ssr;\n\nexport function withUrqlClient(\n  getClientConfig: NextUrqlClientConfig,\n  options?: WithUrqlClientOptions\n) {\n  if (!options) options = {};\n\n  return (AppOrPage: NextPage<any> | typeof NextApp) => {\n    const shouldEnableSuspense = Boolean(\n      (AppOrPage.getInitialProps || options!.ssr) && !options!.neverSuspend\n    );\n\n    const withUrql = ({ urqlClient, urqlState, ...rest }: WithUrqlProps) => {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      const forceUpdate = useState(0);\n\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      const client = React.useMemo(() => {\n        if (urqlClient) {\n          return urqlClient;\n        }\n\n        if (!ssr || typeof window === 'undefined')\n          ssr = ssrExchange({ initialState: urqlState });\n\n        const clientConfig = getClientConfig(ssr);\n        if (!clientConfig.exchanges) {\n          // When the user does not provide exchanges we make the default assumption.\n          clientConfig.exchanges = [\n            dedupExchange,\n            cacheExchange,\n            ssr,\n            fetchExchange,\n          ];\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return initUrqlClient(clientConfig, shouldEnableSuspense)!;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n      }, [urqlClient, urqlState, forceUpdate[0]]);\n\n      const resetUrqlClient = () => {\n        resetClient();\n        ssr = ssrExchange({ initialState: undefined });\n        forceUpdate[1](forceUpdate[0] + 1);\n      };\n\n      return (\n        <Provider value={client}>\n          <AppOrPage\n            urqlClient={client}\n            resetUrqlClient={resetUrqlClient}\n            {...rest}\n          />\n        </Provider>\n      );\n    };\n\n    // Set the displayName to indicate use of withUrqlClient.\n    withUrql.displayName = `withUrqlClient(${getDisplayName(AppOrPage)})`;\n\n    if (AppOrPage.getInitialProps || options!.ssr) {\n      withUrql.getInitialProps = async (appOrPageCtx: NextUrqlContext) => {\n        const { AppTree } = appOrPageCtx;\n\n        // Determine if we are wrapping an App component or a Page component.\n        const isApp = !!(appOrPageCtx as AppContext).Component;\n        const ctx = isApp\n          ? (appOrPageCtx as AppContext).ctx\n          : (appOrPageCtx as NextPageContext);\n\n        const ssrCache = ssrExchange({ initialState: undefined });\n        const clientConfig = getClientConfig(ssrCache, ctx);\n        if (!clientConfig.exchanges) {\n          // When the user does not provide exchanges we make the default assumption.\n          clientConfig.exchanges = [\n            dedupExchange,\n            cacheExchange,\n            ssrCache,\n            fetchExchange,\n          ];\n        }\n\n        const urqlClient = initUrqlClient(clientConfig, !options!.neverSuspend);\n\n        if (urqlClient) {\n          (ctx as NextUrqlContext).urqlClient = urqlClient;\n        }\n\n        // Run the wrapped component's getInitialProps function.\n        let pageProps = {} as any;\n        if (AppOrPage.getInitialProps) {\n          pageProps = await AppOrPage.getInitialProps(appOrPageCtx as any);\n        }\n\n        // Check the window object to determine whether or not we are on the server.\n        // getInitialProps runs on the server for initial render, and on the client for navigation.\n        // We only want to run the prepass step on the server.\n        if (typeof window !== 'undefined') {\n          return { ...pageProps, urqlClient };\n        }\n\n        const props = { ...pageProps, urqlClient };\n        const appTreeProps = isApp ? props : { pageProps: props };\n\n        // Run the prepass step on AppTree. This will run all urql queries on the server.\n        if (!options!.neverSuspend)\n          await ssrPrepass(<AppTree {...appTreeProps} />);\n\n        return {\n          ...pageProps,\n          urqlState: ssrCache ? ssrCache.extractData() : undefined,\n          urqlClient,\n        };\n      };\n    }\n\n    return withUrql;\n  };\n}\n"],"names":["urqlClient","options","const","client","ssr","initialState","getClientConfig","exchanges","ssrPrepass","ctx","clientConfig","AppOrPage","then","getInitialProps"],"mappings":";;;;;EAMEA;;;;;;;;;;;;;;AAkByC;;;;;;;;AAPzC;;;;;;;;;;;;ICacC;;;;yBAGZC;;;;;;uCASQC;;;;;;;;oDAEKH,yCAIPI;YAAoBC;;;0CAEDC;;YACjBD,cAAcE;;;;;;;;UAiBD,EAAjBP;;;;;QAOIA,YAAYG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iCAyDRK;;;;;;;;;;;;;4BAlCJC;;;UAAAA,2CAAcF;;YAEhBG;;;YAWCD;;;;;;;;;;;UAzBHE,wCAAJC;iBACWC;;;;;"}